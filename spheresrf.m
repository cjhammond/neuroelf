function srf = spheresrf(r, f, c, col, rsc)
% spheresrf  - create a new sphere SRF
%
% FORMAT:       srf = spheresrf([radius, factor, center, color, rsc])
%
% Input fields:
%
%       radius      radius in BV units (mm, default: 140)
%       factor      number of faces factor, 20 * (4 ^ f) (default: 6)
%       center      center of sphere (default: [128, 128, 128])
%       color       RGBA color (default: [1, 0.7, 0.3, 1]);
%       rsc         re-scale after each iteration (default: false)
%
% Output fields:
%
%       srf         valid SRF object with specified properties

% Version:  v0.9d
% Build:    14062921
% Date:     Jun-29 2014, 9:24 PM EST
% Author:   Jochen Weber, SCAN Unit, Columbia University, NYC, NY, USA
% URL/Info: http://neuroelf.net/

% Copyright (c) 2010, 2014, Jochen Weber
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%     * Redistributions of source code must retain the above copyright
%       notice, this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of Columbia University nor the
%       names of its contributors may be used to endorse or promote products
%       derived from this software without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
% ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
% WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
% DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
% DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
% (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
% ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

% argument check
if nargin < 1 || ...
   ~isa(r, 'double') || ...
    numel(r) ~= 1 || ...
    isinf(r) || ...
    isnan(r) || ...
    r <= 0
    r = 140;
end
if nargin < 2 || ...
   ~isa(f, 'double') || ...
    numel(f) ~= 1 || ...
    isinf(f) || ...
    isnan(f) || ...
    f < 0 || ...
    f > 9
    f = 6;
else
    f = round(f);
end
if nargin < 3 || ...
   ~isa(c, 'double') || ...
    numel(c) ~= 3 || ...
    any(isinf(c) | isnan(c) | c < -512 | c > 512)
    c = [128, 128, 128];
else
    c = c(:)';
end
if nargin < 4 || ...
   ~isa(col, 'double') || ...
    numel(col) ~= 4 || ...
    any(isinf(col(:)) | isnan(col(:)) | col(:) < 0 | col(:) > 1)
    col = [1, 0.7, 0.3, 1];
else
    col = col(:)';
end
if nargin < 5 || ...
   ~islogical(rsc) || ...
    numel(rsc) ~= 1
    rsc = false;
end

% create output
srf = bless(xff('new:srf'), 1);
numvert = 2 + 10 * (4 ^ f);
numsurf = 20 * (4 ^ f);
srf.NrOfVertices = numvert;
srf.NrOfTriangles = numsurf;
srf.MeshCenter = c;
srf.ConvexRGBA = col;
srf.VertexNormal = zeros(numvert, 3);

% fill first 12 vertices neighbors
gr = (1 + sqrt(5)) / 2;
g1 = gr / sqrt(1 + gr * gr);
g2 = 1 / sqrt(1 + gr * gr);
vert(1:12, :) = [ ...
   -g2,   0,  g1; ...
    g2,   0,  g1; ...
   -g2,   0, -g1; ...
    g2,   0, -g1; ...
     0,  g1,  g2; ...
     0,  g1, -g2; ...
     0, -g1,  g2; ...
     0, -g1, -g2; ...
    g1,  g2,   0; ...
   -g1,  g2,   0; ...
    g1, -g2,   0; ...
   -g1, -g2,   0];
tria = [ ...
     1,  2,  7; ...
     1,  5,  2; ...
     1,  7, 12; ...
     1, 10,  5; ...
     1, 12, 10; ...
     2,  5,  9; ...
     2,  9, 11; ...
     2, 11,  7; ...
     3,  4,  6; ...
     3,  6, 10; ...
     3,  8,  4; ...
     3, 10, 12; ...
     3, 12,  8; ...
     4,  8, 11; ...
     4,  9,  6; ...
     4, 11,  9; ...
     5,  6,  9; ...
     5, 10,  6; ...
     7,  8, 12; ...
     7, 11,  8];

% divide triangles
for dc = 1:f
    [tria, vert] = mesh_tridivide(tria, vert);
    if rsc
        vert = r .* (vert ./ (sqrt(sum(vert .* vert, 2)) * ones(1, 3)));
    end
end

% scale and move
if rsc
    vert = vert + ones(numvert, 1) * c;
else
    vert = r .* (vert ./ (sqrt(sum(vert .* vert, 2)) * ones(1, 3))) + ...
        ones(numvert, 1) * c;
end

% put arrays into SRF
srf.VertexCoordinate = vert;
srf.TriangleVertex = tria;
srf.Neighbors = mesh_trianglestoneighbors(size(vert, 1), tria);
srf.VertexColor = zeros(numvert, 4);

% recalc normals
srf.RecalcNormals;
