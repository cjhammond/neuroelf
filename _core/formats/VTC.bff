# BinaryFileFormat (leave this tag as magic token!)

# BrainVoyager QX file format for *.VTC files (Volumetric TimeCourse)
# VTC FileVersions supported: 1, 2, 3
#
# A VTC file contains the functional data (time series) of one
# experimental run in a 3D format, i.e. in Talairach space. The
# binary file contains a variable-length header followed by the
# actual 4D data.
#
# Version:  v0.9c
# Build:    13032913
# Date:     Nov-20 2012, 3:48 PM EST
# Author:   Jochen Weber, SCAN Unit, Columbia University, NYC, NY, USA
# URL/Info: http://neuroelf.net/

# FILE FORMAT
DefaultProperty:VTCData
Description:Volume time course files
EncodingSyntax:ieee-le
Extensions:vtc

# FIELDS
ListOfFields:!
type  !cond                   !disktype!datatype!dim                      !default !varname

# for writing, don't trust values...
BLOOP !$BFFWRITE              ! ! !1 ! !WriteChecks
EXPRE !!!!!! ...
$TXYZDim=size(@VTCData); ...
@NrOfVolumes=$TXYZDim(1); ...
$XDim=$TXYZDim(2); ...
$YDim=$TXYZDim(3); ...
$ZDim=$TXYZDim(4); ...
tv_XDim = (@XEnd - @XStart) / @Resolution; ...
tv_YDim = (@YEnd - @YStart) / @Resolution; ...
tv_ZDim = (@ZEnd - @ZStart) / @Resolution; ...
if tv_XDim ~= $XDim || tv_YDim ~= $YDim || tv_ZDim ~= $ZDim, ...
    error('Wrong dimensions.'); ...
end
EXPRE !@FileVersion < 3   !!!!!@DataType = 1; if istransio(@VTCData), @VTCData = uint16(@VTCData(:, :, :, :)); end, @NrOfLinkedPRTs = 1; if iscell(@NameOfLinkedPRT) && ~isempty(@NameOfLinkedPRT), @NameOfLinkedPRT = @NameOfLinkedPRT{1}(:)'; elseif ~ischar(@NameOfLinkedPRT), @NameOfLinkedPRT = '<none>'; else, @NameOfLinkedPRT = @NameOfLinkedPRT(:)'; end
EXPRE !@FileVersion > 2   !!!!!if ~isempty(@VTCData), tv_data = @VTCData(1); switch(lower(class(tv_data))), case{'uint16'}, @DataType = 1; case {'single'}, @DataType = 2; end, end, if ischar(@NameOfLinkedPRT) && ~isempty(@NameOfLinkedPRT), @NrOfLinkedPRTs = 1; @NameOfLinkedPRT = {@NameOfLinkedPRT(:)'}; elseif ~iscell(@NameOfLinkedPRT), @NrOfLinkedPRTs = 0; @NameOfLinkedPRT = cell(0, 1); else, @NrOfLinkedPRTs = numel(@NameOfLinkedPRT); @NameOfLinkedPRT = @NameOfLinkedPRT(:); end
ELOOP !                       ! ! !  ! !WriteChecks

# header fields
FIELD !                       !uint16  !double  !1, 1                     !        !FileVersion
FIELD !                       !cstring !cstring !1, 1                     !        !NameOfSourceFMR
EXPRE !$BFFREAD           !!!!!@NrOfLinkedPRTs = 1; @NameOfLinkedPRT = cell(0, 1);
FIELD !@FileVersion > 2       !uint16  !double  !1, 1                     !        !NrOfLinkedPRTs
FIELD !@NrOfLinkedPRTs > 0    !cstring !cstring !@NrOfLinkedPRTs, 1       !        !NameOfLinkedPRT
EXPRE !$BFFREAD           !!!!!@NrOfCurrentPRT = 0; @DataType = 1; @NrOfVolumes = 1;
EXPRE !$BFFWRITE          !!!!!@NrOfCurrentPRT = @NrOfCurrentPRT - 1;
FIELD !@FileVersion > 2       !uint16  !double  !1, 1                     !        !NrOfCurrentPRT
FIELD !@FileVersion > 2       !uint16  !double  !1, 1                     !        !DataType
EXPRE !                   !!!!!@NrOfCurrentPRT = @NrOfCurrentPRT + 1;
FIELD !                       !uint16  !double  !1, 1                     !        !NrOfVolumes
FIELD !                       !uint16  !double  !1, 1                     !        !Resolution
FIELD !                       !uint16  !double  !1, 1                     !        !XStart
FIELD !                       !uint16  !double  !1, 1                     !        !XEnd
FIELD !                       !uint16  !double  !1, 1                     !        !YStart
FIELD !                       !uint16  !double  !1, 1                     !        !YEnd
FIELD !                       !uint16  !double  !1, 1                     !        !ZStart
FIELD !                       !uint16  !double  !1, 1                     !        !ZEnd
EXPRE !$BFFREAD           !!!!!$XDim = (@XEnd - @XStart) / @Resolution;
EXPRE !$BFFREAD           !!!!!$YDim = (@YEnd - @YStart) / @Resolution;
EXPRE !$BFFREAD           !!!!!$ZDim = (@ZEnd - @ZStart) / @Resolution;
EXPRE !$BFFREAD           !!!!!@Convention = 0; @ReferenceSpace = 0; @HemodynamicDelay = 1; @TR = 2000; @HrfDelta = 2.5; @HrfTau = 1.25; @SegmentSize = 10; @SegmentOffset = 0;
FIELD !@FileVersion > 2       !uint8   !double  !1, 1                     !        !Convention
FIELD !@FileVersion > 2       !uint8   !double  !1, 1                     !        !ReferenceSpace
FIELD !@FileVersion < 3       !int16   !double  !1, 1                     !        !HemodynamicDelay
FIELD !                       !single  !double  !1, 1                     !        !TR
FIELD !@FileVersion < 3       !single  !double  !1, 1                     !        !HrfDelta
FIELD !@FileVersion < 3       !single  !double  !1, 1                     !        !HrfTau
FIELD !@FileVersion < 3       !uint16  !double  !1, 1                     !        !SegmentSize
FIELD !@FileVersion < 3       !int16   !double  !1, 1                     !        !SegmentOffset
FIELD !~$HEADERONLY && @DataType == 1 !uint16 !uint16 !@NrOfVolumes, $XDim, $YDim, $ZDim!!VTCData
FIELD !~$HEADERONLY && @DataType == 2 !single !single !@NrOfVolumes, $XDim, $YDim, $ZDim!!VTCData
EXPRE ! $HEADERONLY       !!!!!@VTCData = []; fseek(fid, 2 * @DataType * @NrOfVolumes * $XDim * $YDim * $ZDim, 0);

# Read rest of File into REMAININGCONTENT
EXPRE !$HEADERONLY        !!!!!fseek(fid, 0, 1);
EXPRE !$BFFREAD   !  !  !  !  !$RemSize = $FILESIZE - ftell(fid);
EXPRE !$BFFWRITE  !  !  !  !  !$RemSize = 0; try, if isfield(@@, 'REMAININGCONTENT'), $RemSize = prod(size(@REMAININGCONTENT)); end, end
FIELD !$RemSize > 0           !uint8   !uint8   !1, $RemSize              !        !REMAININGCONTENT

# pre-set RunTimeVars on reading
EXPRE !$BFFREAD   !  !  !  !  !@RunTimeVars = struct('Discard', []);
EndListOfFields

# new file code snippet
NewFileCode:!
@FileVersion = 2;
@NameOfSourceFMR = '';
@NrOfLinkedPRTs = 1;
@NameOfLinkedPRT = '';
@NrOfCurrentPRT = 1;
@DataType = 1;
@NrOfVolumes = 0;
@Resolution = 3;
@XStart = 57;
@XEnd = 231;
@YStart = 52;
@YEnd = 172;
@ZStart = 59;
@ZEnd = 197;
tXDim = (@XEnd - @XStart) / @Resolution;
tYDim = (@YEnd - @YStart) / @Resolution;
tZDim = (@ZEnd - @ZStart) / @Resolution;
@Convention = 1;
@ReferenceSpace = 3; 
@HemodynamicDelay = 1;
@TR = 2000;
@HrfDelta = 2.5;
@HrfTau = 1.25;
@SegmentSize = 10;
@SegmentOffset = 0;
@VTCData = uint16(zeros([@NrOfVolumes, tXDim, tYDim, tZDim]));
@RunTimeVars = struct;
@RunTimeVars.AutoSave = false;
@RunTimeVars.AvgGlobSigRemoved = false;
@RunTimeVars.AvgGrouping = 'none';
@RunTimeVars.AvgGroupSTC = 'st';
@RunTimeVars.AvgTransformationType = 3;
@RunTimeVars.AvgVTC = false;
@RunTimeVars.AvgWindowFrom = 0;
@RunTimeVars.AvgWindowStep = 1000;
@RunTimeVars.AvgWindowTo = 20000;
@RunTimeVars.BaseWindowFrom = -4000;
@RunTimeVars.BaseWindowStep = 2000;
@RunTimeVars.BaseWindowTo = 0;
@RunTimeVars.Discard = [];
@RunTimeVars.NrOfConditions = 2;
@RunTimeVars.NrOfConditionOnsets = [0, 0];
@RunTimeVars.NrOfSourceAVGVTCs = 0;
@RunTimeVars.NrOfSourceVTCs = 1;
@RunTimeVars.NrOfSubjects = 1;
@RunTimeVars.NrOfTCsPerCondition = 2;
@RunTimeVars.NrOfVolumesPerTC = 21;
@RunTimeVars.ConditionCollasping = cell(0, 2);
@RunTimeVars.ConditionColors = uint8(zeros(2, 16));
@RunTimeVars.ConditionNames = {'A', 'B'};
@RunTimeVars.ConditionOnsets = {zeros(0, 2), zeros(0, 2)};
@RunTimeVars.ConditionThresholds = cat(1, zeros(1, 2, 2), ones(1, 2, 2));
@RunTimeVars.SourcePRTs = {'Subject_Source.prt'};
@RunTimeVars.SourceVTCs = {'Subject_Source.vtc'};
@RunTimeVars.SubjectAVGVTCs = {};
@RunTimeVars.SubjectNames = {'Subject'};
@RunTimeVars.TCNames = {'mean', 'sd'};
@RunTimeVars.TCOnsetWeights = single(zeros(84, 1));
EndNewFileCode
