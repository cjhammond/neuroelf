# TextFileFormat (leave this tag as magic token!)

# PLYA file format for ASCII *.ply files (PoLYgon file format/Stanford)
# PLY FileVersions supported: 1.0
#
# Version:  v0.9d
# Build:    14062018
# Date:     Jun-20 2014, 6:20 PM EST
# Author:   Jochen Weber, SCAN Unit, Columbia University, NYC, NY, USA
# URL/Info: http://neuroelf.net/

# FILE FORMAT
Description:Stanford Triangle or PoLYgon file (*.ply)
Extensions:plya # dummy extension
FieldDelimiters: {[32]}
LineDelimiters: {[13, 10], [10]}
ParagraphArrays:0
SkipEmptyLines:1
Magic:|
name          |range       |type    |magic
PLYA_ASCIIPLY |1, 24       |regexpi |^ply.*format\sascii\s1\.0
EndMagic

# FIELDS
ListOfFields:!
type !cond               !field               !datatype!format !dim    !default !varname

# no write support at this time
EXPRE!$TFFWRITE     !!!!!!error('No PLY write support yet.');

# parse header
WRTLN!!!!!!!ply
WRTLN!!!!!!!format ascii 1.0

EXPRE!$TFFREAD      !!!!!! ...
mydtlist = { ...
    'char', 'int8', 'uchar', 'uint8',  ...
    'short', 'int16', 'ushort', 'uint16', ...
    'int', 'int32', 'uint', 'uint32', ...
    'float', 'float32', 'double', 'float64'}; ...
mydttarg = { ...
    'int8', 'uint8', ...
    'int16', 'uint16', ...
    'int32', 'uint32', ...
    'single', 'double'}; ...
@Comments = {}; ...
@NrOfElements = 0; ...
@Elements = emptystruct({'Name', 'Number', 'Format', 'FixedLength', 'Data'}); ...
@Obj_Info = {}; ...
$ec = 0; ...
hdcmpl = false;

BLOOP!$TFFREAD           ! ! ! !10000 ! !RH
EXPRE!              !!!!!! ...
tlcont = linecont{linec}; ...
tltype = regexprep(tlcont, '^([a-z][a-z_]*)\s*.*$', '$1'); ...
tlcont = regexprep(tlcont, '^[a-z][a-z_]*\s(.*)$', '$1'); ...
tnh = true; ...
linec = linec + 1;

EXPRE!tnh && strcmpi(tltype, 'comment')   !!!!!!tnh = false; @Comments{end+1} = tlcont;

EXPRE!tnh && strcmpi(tltype, 'end_header')!!!!!!tnh = false; $RH = 10000; hdcmpl = true;

EXPRE!tnh && strcmpi(tltype, 'obj_info')  !!!!!!tnh = false; @Obj_Info{end+1} = tlcont;

EXPRE!tnh && strcmpi(tltype, 'element')   !!!!!! ...
$ec = $ec + 1; ...
elname = regexprep(tlcont, '^([a-z][a-z_]*)\s.*$', '$1'); ...
elnumb = regexprep(tlcont, '^.*\s+(\d+)$', '$1'); ...
@Elements($ec).Name = elname; ...
@Elements($ec).Number = str2double(elnumb); ...
@Elements($ec).Format = emptystruct({'Name', 'Datatype', 'Listtype', 'Listlength'}); ...
@Elements($ec).FixedLength = true; ...
@Elements($ec).Data = []; ...
$pc = 0;

BLOOP!tnh && strcmpi(tltype, 'element')! ! ! !100 ! !RP
EXPRE!              !!!!!! ...
tlcont = linecont{linec}; ...
tltype = regexprep(tlcont, '^([a-z][a-z_]*)\s*.*$', '$1'); ...
tlcont = regexprep(tlcont, '^[a-z][a-z_]*\s(.*)$', '$1'); ...
enh = true; ...
linec = linec + 1;

EXPRE!enh && strcmpi(tltype, 'comment')   !!!!!!enh = false; @Comments{end+1} = tlcont;

EXPRE!enh && strcmpi(tltype, 'property')  !!!!!! ...
enh = false; ...
$pc = $pc + 1; ...
dtcont = splittocell(tlcont, ' ', 1, 1); ...
@Elements($ec).Format($pc).Name = dtcont{end}; ...
mydtfound = strcmpi(dtcont{1}, mydtlist); ...
mydtislist = strcmpi(dtcont{1}, 'list'); ...
if any(mydtfound), ...
    @Elements($ec).Format($pc).Datatype = mydttarg{floor((1+find(mydtfound))/2)}; ...
elseif ~mydtislist, ...
    error(['Invalid property datatype: ' dtcont{1} '.']); ...
else, ...
    @Elements($ec).FixedLength = false; ...
    @Elements($ec).Format($pc).Datatype = 'list'; ...
    @Elements($ec).Format($pc).Listtype = dtcont{3}; ...
    @Elements($ec).Format($pc).Listlength = -1; ...
end

EXPRE!enh && any(strcmpi(tltype, {'element', 'end_header'})) !!!!!! ...
enh = false; ...
$RP = 100; ...
linec = linec - 1; ...
if @Elements($ec).FixedLength, ...
    @Elements($ec).FixedLength = numel(@Elements($ec).Format); ...
end

EXPRE!enh           !!!!!!error(['Invalid tag in element: ' tltype '.']);
ELOOP!                   ! ! ! !  ! !RP
ELOOP!                   ! ! ! !  ! !RH
EXPRE!$TFFREAD && ~hdcmpl !!!!!!error('Header incomplete after at least 10000 lines.');
EXPRE!              !!!!!!@NrOfElements = numel(@Elements);

# read elements
BLOOP!                   ! ! ! !@NrOfElements ! !EC

EXPRE!@Elements($EC).FixedLength !!!!!! ...
try, ...
    @Elements($EC).Data = ...
        reshape(eval(['[' gluetostring(linecont(linec:linec+@Elements($EC).Number-1), ',') ']']), ...
        [@Elements($EC).FixedLength, @Elements($EC).Number])'; ...
    linec = linec + @Elements($EC).Number; ...
catch ne_eo; ...
    neuroelf_lasterr(ne_eo); ...
    error('Invalid element line in file.'); ...
end

EXPRE!~@Elements($EC).FixedLength!!!!!! ...
try, ...
    fxlen = zeros(1, @Elements($EC).Number); ...
    @Elements($EC).Data = linecont(linec:linec+@Elements($EC).Number-1); ...
    linec = linec + @Elements($EC).Number; ...
    for slinec = 1:numel(@Elements($EC).Data), ...
        try, ...
            @Elements($EC).Data{slinec} = eval(['[' @Elements($EC).Data{slinec} ']']); ...
            fxlen(slinec) = numel(@Elements($EC).Data{slinec}); ...
        end, ...
    end, ...
    if ~any(diff(fxlen)), ...
        @Elements($EC).FixedLength = fxlen(1); ...
        fxdat = zeros(numel(@Elements($EC).Data), fxlen(1)); ...
        for slinec = 1:numel(fxlen), ...
            fxdat(slinec, :) = @Elements($EC).Data{slinec}; ...
        end, ...
        @Elements($EC).Data = fxdat; ...
    end, ...
catch ne_eo; ...
    neuroelf_lasterr(ne_eo); ...
    error('Invalid elements line.'); ...
end

ELOOP!                   ! ! ! !  ! !EC

EndListOfFields

NewFileCode:!
@Comments = {};
@NrOfElements = 0;
@Elements = emptystruct({'Name', 'Number', 'Format', 'FixedLength', 'Data'});
@Obj_Info = {};
EndNewFileCode
